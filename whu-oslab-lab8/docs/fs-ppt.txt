第八节
文件系统

File System

《操作系统实践A》

169

08 实验目的

Ø 通过深入分析 xv6 操作系统文件系统（FS, File System）的实现细节，掌握现代操作系统文

件系统的基本结构、核心机制与一致性保障方法，最终能够 **独立设计并实现一个功能完善

的带日志的文件系统（Journaling File System）。

Ø 主要学习目标

p 1. 理解文件系统的基本原理

p 2. 掌握 xv6 文件系统的架构与实现

p 3. 实现写前日志系统（Write-Ahead Logging, WAL）

p 4. 设计与实现自己的日志文件系统

08 核心学习资料

Ø 文件系统理论基础

p 操作系统概念 第13-14章：文件系统接口和实现

p xv6手册 第10章：文件系统

08 xv6文件系统源码分析

Ø kernel/fs.h - 文件系统结构定义

p 重点：超级块、inode、目录项的格式

Ø kernel/fs.c - 文件系统核心实现

p 重点函数： ialloc() , iget() , iput() , namei()

Ø kernel/file.c - 文件描述符管理

p 重点：打开文件表、文件描述符分配

Ø kernel/log.c - 日志系统实现

p 重点：事务处理、崩溃恢复、写前日志

Ø kernel/bio.c - 块缓存管理

p 重点：缓存策略、磁盘I/O调度

08 磁盘和存储

Ø 理解磁盘结构：扇区、柱面、磁头

Ø QEMU磁盘模拟：virtio-blk设备的使用

p virtio-blk的核心优势

p 高性能：半虚拟化： Guest OS（虚拟机内的系统）知道自己在虚拟化环境中运行，并

安装了专门的virtio-blk驱动。它与QEMU的Hypervisor通过一个高效的、基于共享内存

和环形缓冲区的通信机制（virtqueue）交换数据。

p 对比： 相比于模拟真实硬件（如SATA控制器），它避免了大量不必要的硬件仿真和中断

开销，I/O路径更短，性能显著更高。

p 低开销： 减少了VM Exits（虚拟机退出），降低了CPU占用率。

08 磁盘和存储

Ø QEMU磁盘模拟：virtio-blk设备的使用

p 终端 1：启动QEMU并等待调试器连接。

qemu-system-riscv64 -machine virt -nographic -bios none -kernel my_os.elf -s -S

p 终端 2：启动GDB并连接。

riscv64-unknown-elf-gdb my_os.elf
(gdb) target remote localhost:1234
(gdb) b _start  # 在起始处设置断点
(gdb) continue   # 开始执行

p 使用VirtIO块设备：为QEMU虚拟机添加一个VirtIO块设备，并关联到虚拟硬盘镜像 

fs.img

qemu-system-riscv64 -machine virt -drive file=fs.img,if=none,format=raw,id=x0 -device 
virtio-blk-device,drive=x0

08 任务1：理解xv6文件系统布局

Ø 学习重点：

Ø 1. 分析磁盘布局结构：

| boot | super | log | inode blocks | bitmap | data blocks |
|    0    |     1    | 2-? |          ?-?        |      ?      |      ?-end      |

p 每个区域的作用是什么？

p 为什么要这样组织？

p 各区域的大小如何确定？

08 任务1：理解xv6文件系统布局

Ø 学习重点：

区域名称

块范围

作用

内容

特点/工作机制

引导块 (Boot Block) 块0

存储系统启动代码

超级块 (Super Block) 块1

存储文件系统元数
据

引导加载程序
(bootloader)

• 文件系统大小(总块数)
• 数据块数量
• inode数量
• 日志区域大小
• 魔数(识别文件系统类
型)

日志区域 (Log 
Blocks)

块2到?

实现事务性写入，
保证文件系统一致
性

事务操作记录

• 仅第0块用于引导
• 非启动系统时此块可为空
• 确保系统正确加载内核

• 操作系统首先读取此块
• 包含文件系统关键结构信息

工作方式:
1. 写入操作先记录到日志
2. 操作完成后提交日志
3. 实际写入目标位置
4. 崩溃恢复时重放或撤销
大小: 通常固定数量块(如30块)

08 任务1：理解xv6文件系统布局

区域名称

块范围

作用

内容

特点/工作机制

inode块 (Inode 
Blocks)

?到?

存储文件元数
据

每个inode包含:
• 文件类型
• 文件大小
• 链接计数
• 数据块指针
• 权限信息

位图块 (Bitmap Block) 块?

跟踪数据块的
使用状态

位图数据

组织方式:
• 每个inode固定大小(256字节)
• 每个块包含多个inode
• 通过索引快速访问

工作机制:
• 每个位对应一个数据块
• 0 = 空闲, 1 = 已使用
• 快速查找空闲块
数量: 通常1个块足够管理大量
数据块

数据块 (Data Blocks)

?到end

存储实际文件
内容

• 文件数据
• 目录条目(文件名
+inode编号)
• 间接块指针

管理方式:
• 通过位图分配和释放
• 支持直接和间接指针
• 存储用户文件和目录数据

08 任务1：理解xv6文件系统布局

Ø 2. 理解超级块（superblock）的作用：

struct superblock {

uint magic; // 文件系统魔数
uint size; // 文件系统大小（块数）
uint nblocks; // 数据块数量
uint ninodes; // inode数量
uint nlog; // 日志块数量
uint logstart; // 日志起始块号
uint inodestart; // inode区起始块号
uint bmapstart; // 位图起始块号

};

p 为什么需要这些元数据？

p 如何确保超级块的一致性？

08 任务1：理解xv6文件系统布局

Ø 3. 深入理解inode结构：

struct dinode {

short type; // 文件类型
short major; // 主设备号
short minor; // 次设备号
short nlink; // 硬链接计数
uint size; // 文件大小
uint addrs[NDIRECT+1]; // 数据块地址

};

p 直接块和间接块的设计思路

p 如何支持大文件？

p 硬链接机制的实现

08 任务1：理解xv6文件系统布局

Ø 深入思考：

Ø 为什么选择这种简单的布局？

Ø 如何提高空间利用率？

Ø 现代文件系统有什么改进？

08 任务2：分析xv6的inode管理机制

Ø 代码阅读：

Ø 1. 研读inode缓存管理：

p 内存inode和磁盘inode的关系

p 引用计数的作用和管理

p 缓存一致性如何保证

struct inode {

uint dev; // 设备号
uint inum; // inode号
int ref; // 引用计数
struct sleeplock lock; // 保护inode内容
int valid; // inode已从磁盘读取？
// 从磁盘拷贝的内容
short type;
short major;
short minor;
short nlink;
uint size;
uint addrs[NDIRECT+1];

};

08 任务2：分析xv6的inode管理机制

Ø 2. 分析inode分配算法：

struct inode* ialloc(uint dev, short type) {
// 1. 在inode位图中找空闲inode
// 2. 初始化inode内容
// 3. 写入磁盘
// 4. 返回内存中的inode

}

p 如何快速找到空闲inode？

p 分配失败时的处理策略

p 并发分配的同步机制

08 任务2：分析xv6的inode管理机制

Ø 3. 理解文件数据块管理：

static uint bmap(struct inode *ip, uint bn) {

// bn是文件内的逻辑块号
// 返回对应的物理块号
// 处理直接块和间接块的映射

}

p 逻辑块号到物理块号的转换

p 间接块的实现机制

p 如何扩展文件大小

08 任务2：分析xv6的inode管理机制

Ø 关键问题：

p inode缓存的替换策略是什么？

p 如何防止inode泄漏？

p 大文件的性能问题如何解决？

08 任务3：设计你的文件系统布局

Ø 设计要求：

p 1. 确定磁盘分区方案

p 2. 设计inode和数据块组织

p 3. 选择合适的块大小

Ø 你需要考虑的问题：

p 1. 如何平衡小文件和大文件的效率？

p 2. 是否需要扩展属性支持？

p 3. 如何优化目录性能？

p 4. 是否支持符号链接？

// 你的文件系统布局设计
#define BLOCK_SIZE 4096 // 块大小选择的考虑
#define SUPERBLOCK_NUM 1 // 超级块位置
#define LOG_START 2 // 日志区起始
#define LOG_SIZE 30 // 日志区大小

// inode设计
struct my_inode {

uint16_t mode; // 文件模式和类型
uint16_t uid; // 所有者ID
uint32_t size; // 文件大小
uint32_t blocks; // 分配的块数
uint32_t atime, mtime, ctime; // 时间戳
uint32_t direct[12]; // 直接块指针
uint32_t indirect; // 一级间接块
uint32_t double_indirect; // 二级间接块（可选）

};

08 任务4：实现块缓存系统

Ø 参考xv6的bio.c，理解：

p 1. 缓存结构设计：

struct buf {

int valid; // 缓存是否有效
int disk; // 是否需要写回磁盘
uint dev; // 设备号
uint blockno; // 块号
struct sleeplock lock; // 保护缓存内容
uint refcnt; // 引用计数
struct buf *prev, *next; // LRU链表
uchar data[BSIZE]; // 实际数据

};

08 任务4：实现块缓存系统

Ø 参考xv6的bio.c，理解：

p 2. 缓存管理策略

struct buf* bread(uint dev, uint blockno); // 读取块
void bwrite(struct buf *b); // 写入块
void brelse(struct buf *b); // 释放块

08 任务4：实现块缓存系统

Ø 实现考虑的问题：

p 1. 缓存大小如何确定？

p 2. 什么时候触发写回？

p 3. 如何处理I/O错误？

p 4. 预读策略是否需要？

// 你的块缓存实现
struct buffer_head {

uint32_t block_num; // 块号
char *data; // 数据指针
int dirty; // 脏位
int ref_count; // 引用计数
struct buffer_head *next; // 哈希链表
struct buffer_head *lru_next, *lru_prev; // LRU链表

};
// 关键函数设计
struct buffer_head* get_block(uint dev, uint block);
void put_block(struct buffer_head *bh);
void sync_block(struct buffer_head *bh);
void flush_all_blocks(uint dev);

08 任务5：实现日志系统

Ø 参考xv6的log.c，深入理解：

Ø 1. 日志的作用和原理：

p 写前日志(Write-Ahead Logging)

p 事务的原子性保证

p 崩溃恢复机制

Ø 2. 日志结构设计：

struct logheader {

int n; // 日志中的块数
int block[LOGSIZE]; // 每个块在文件系统中的位置

};

08 任务5：实现日志系统

Ø 3. 事务处理流程

void begin_op(void); // 开始事务
void log_write(struct buf *b); // 记录写操作
void end_op(void); // 提交事务

08 任务5：实现日志系统

Ø 设计考虑：

p 1. 日志大小如何确定？

p 2. 如何处理日志满的情况？

p 3. 恢复过程如何确保幂等性？

p 4. 如何优化日志性能？

// 日志系统状态
struct log_state {

struct spinlock lock;
int start; // 日志区起始块号
int size; // 日志区大小
int outstanding; // 未完成的系统调用数
int committing; // 是否正在提交
int dev; // 设备号

};
// 关键实现函数
void log_init(int dev, struct superblock *sb);
void begin_transaction(void);
void end_transaction(void);
void log_block_write(struct buffer_head *bh);
void recover_log(void);

08 任务6：实现目录和路径解析

Ø 理解xv6的目录机制：

Ø 1. 目录项格式：

struct dirent {

ushort inum; // inode号，0表示空闲
char name[DIRSIZ]; // 文件名

};

Ø 2. 路径解析算法：

static struct inode* namex(char *path, int nameiparent, char *name) {

// 解析路径，返回对应的inode
// nameiparent=1时返回父目录inode

}

08 任务6：实现目录和路径解析

Ø 需要考虑的问题：

p 1. 目录的最大大小限制

p 2. 长文件名的支持

p 3. 目录遍历的效率

p 4. 硬链接和符号链接的处理

// 目录操作接口
struct inode* dir_lookup(struct inode *dp, char *name, uint *poff);
int dir_link(struct inode *dp, char *name, uint inum);
int dir_unlink(struct inode *dp, char *name);

// 路径解析
struct inode* path_walk(char path); struct inode path_parent(char *path, char *name);

08 测试与调试策略

Ø 文件系统完整性测试

void test_filesystem_integrity(void) {

printf("Testing filesystem integrity…\n");
// 创建测试文件
int fd = open("testfile", O_CREATE | 
O_RDWR);
assert(fd >= 0);
// 写入数据
char buffer[] = "Hello, filesystem!";
int bytes = write(fd, buffer, strlen(buffer));
assert(bytes == strlen(buffer));
close(fd);
// 重新打开并验证
fd = open("testfile", O_RDONLY);
assert(fd >= 0);
char read_buffer[64];

bytes = read(fd, read_buffer, 
sizeof(read_buffer));
read_buffer[bytes] = '\0';

assert(strcmp(buffer, read_buffer) == 0);
close(fd);

// 删除文件
assert(unlink("testfile") == 0);

printf("Filesystem integrity test passed\n");

}

08 测试与调试策略

Ø 并发访问测试

void test_concurrent_access(void) {

printf("Testing concurrent file access…");
// 创建多个进程同时访问文件系统
for (int i = 0; i < 4; i++) {
if (fork() == 0) {

// 子进程：创建和删除文件
char filename[32];
snprintf(filename, sizeof(filename), 
"test_%d", i);

for (int j = 0; j < 100; j++) {
int fd = open(filename, 
O_CREATE | O_RDWR);
if (fd >= 0) {

write(fd, &j, sizeof(j));

}

close(fd);
unlink(filename);

}

}
exit(0);

}

}

// 等待所有子进程完成
for (int i = 0; i < 4; i++) {

wait(NULL);

}
printf("Concurrent access test completed”);

08 测试与调试策略

Ø 崩溃恢复测试，模拟崩溃场景：

p 1. 开始大量文件操作

p 2. 在中途"崩溃"（重启系统）

p 3. 检查文件系统一致性

Ø 注意：这个测试需要特殊的测试框架，可以通过修改内核代码来模拟崩溃

void test_crash_recovery(void) {

printf("Testing crash recovery…");

}

08 测试与调试策略

Ø 性能测试

void test_filesystem_performance(void) {

printf("Testing filesystem performance…\n");
uint64 start_time = get_time();

// 大量小文件测试
for (int i = 0; i < 1000; i++) {
char filename[32];
snprintf(filename, sizeof(filename), "small_%d", i);
 int fd = open(filename, O_CREATE | O_RDWR);
write(fd, "test", 4);
close(fd);

}
uint64 small_files_time = get_time() - start_time;

08 测试与调试策略

Ø 性能测试

// 大文件测试
start_time = get_time();

int fd = open("large_file", O_CREATE | O_RDWR);
char large_buffer[4096];
for (int i = 0; i < 1024; i++) { // 4MB文件

write(fd, large_buffer, sizeof(large_buffer));

}
close(fd);

uint64 large_file_time = get_time() - start_time;

printf("Small files (1000x4B): %lu cycles\n", small_files_time);
printf("Large file (1x4MB): %lu cycles\n", large_file_time);

08 测试与调试策略

Ø 性能测试

// 清理测试文件
for (int i = 0; i < 1000; i++) {
char filename[32];
snprintf(filename, sizeof(filename), "small_%d", i);
unlink(filename);

}
unlink("large_file");

}

08 调试建议

Ø 文件系统状态检查

void debug_filesystem_state(void) {

printf("=== Filesystem Debug Info ===");
// 显示超级块信息
struct superblock sb;
read_superblock(&sb);
printf("Total blocks: %d", sb.size);
printf("Free blocks: %d", count_free_blocks());
printf("Free inodes: %d", count_free_inodes());

// 显示块缓存状态
printf("Buffer cache hits: %d", buffer_cache_hits);
printf("Buffer cache misses: %d", buffer_cache_misses);

}

08 调试建议

Ø inode追踪

void debug_inode_usage(void) {

printf("=== Inode Usage ===\n");
for (int i = 0; i < NINODE; i++) {

struct inode *ip = &icache.inode[i];
if (ip->ref > 0) {

printf("Inode %d: ref=%d, type=%d, size=%d\n",
ip->inum, ip->ref, ip->type, ip->size);

}

}

}

08 调试建议

Ø 磁盘I/O统计

void debug_disk_io(void) {

printf("=== Disk I/O Statistics ===");
printf("Disk reads: %d", disk_read_count);
printf("Disk writes: %d", disk_write_count);

}

08 思考题

Ø 1. 设计权衡：

p xv6的简单文件系统有什么优缺点？

p 如何在简单性和性能之间平衡？

Ø 2. 一致性保证：

p 日志系统如何确保原子性？

p 如果在恢复过程中再次崩溃会怎样？

Ø 3. 性能优化：

p 文件系统的主要性能瓶颈在哪里？

p 如何改进目录查找的效率？

Ø 4. 可扩展性：

p 如何支持更大的文件和文件系统？

p 现代文件系统有哪些先进特性？

Ø 5. 可靠性：

p 如何检测和修复文件系统损坏？

p 如何实现文件系统的在线检查？

End of This Part

